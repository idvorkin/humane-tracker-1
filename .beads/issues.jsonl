{"id":"HT-0g4","title":"Wrap import/replace in Dexie transaction for atomicity","description":"**Severity: Critical**\n\nThe `importAllData()` function in `dataService.ts` performs 4 separate async operations without a transaction wrapper:\n\n```typescript\nif (mode === \"replace\") {\n  await habitRepository.clear();   // Op 1\n  await entryRepository.clear();   // Op 2\n}\nawait habitRepository.bulkPut(habits);   // Op 3\nawait entryRepository.bulkPut(entries);  // Op 4\n```\n\n## Problem\n- Between each step, LiveQuery subscriptions fire and UI sees inconsistent state\n- If error occurs mid-operation (e.g., after clear but before bulkPut), data is lost with no rollback\n- Cloud sync could be pushing/pulling simultaneously, causing merge conflicts\n- Violates Dexie Cloud's atomicity guarantees\n\n## Solution\nWrap in `db.transaction()`:\n\n```typescript\nimport { db } from \"../config/db\";\n\nreturn db.transaction('rw', db.habits, db.entries, async () =\u003e {\n  if (mode === \"replace\") {\n    await db.habits.clear();\n    await db.entries.clear();\n  }\n  await db.habits.bulkPut(habitsRecords);\n  await db.entries.bulkPut(entriesRecords);\n});\n```\n\n## Reference\nhttps://dexie.org/docs/cloud/consistency\n\u003e \"Any Dexie transaction will be regarded as an atomic all-or-nothing operation when it syncs to the cloud.\"","acceptance_criteria":"- [ ] importAllData wrapped in db.transaction()\n- [ ] All 4 operations (clear habits, clear entries, bulkPut habits, bulkPut entries) in same transaction\n- [ ] Error in any step rolls back entire operation\n- [ ] Existing tests still pass\n- [ ] Manual test: import with intentional error mid-way doesn't corrupt data","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-13T14:17:40.317568536Z","updated_at":"2025-12-13T14:53:27.38201373Z","closed_at":"2025-12-13T14:53:27.38201373Z","labels":["critical","data-integrity","sync"],"dependencies":[{"issue_id":"HT-0g4","depends_on_id":"HT-er4","type":"parent-child","created_at":"2025-12-13T14:17:47.069925935Z","created_by":"daemon"}]}
{"id":"HT-0r2","title":"Fix read-condition-write race in CleanupDuplicates","description":"**Severity: Medium**\n\n`CleanupDuplicates.tsx` uses a read-condition-write pattern that's vulnerable to race conditions with cloud sync.\n\n## Current Code\n```typescript\n// Read all habits\nconst habits = await habitService.getAllHabitsForUser(userId);\n// Find duplicates in JS\nconst duplicates = findDuplicates(habits);\n// Delete sequentially\nfor (const dup of duplicates) {\n  await habitService.deleteHabit(dup.id);  // Each delete triggers subscription\n}\n```\n\n## Problems\n1. If cloud sync pushes a new habit between read and delete, could delete wrong item\n2. Sequential deletes trigger subscription updates between each one\n3. User could add a habit during cleanup, causing unpredictable behavior\n\n## Solution Options\n\n**Option A: Batch delete in transaction**\n```typescript\nawait db.transaction('rw', db.habits, async () =\u003e {\n  const duplicateIds = [...]; // IDs determined before transaction\n  await db.habits.bulkDelete(duplicateIds);\n});\n```\n\n**Option B: Use where-clause (preferred for Dexie Cloud)**\n```typescript\n// Group habits by name, delete all but first in each group\n// Conditions travel to server and re-execute there\n```\n\n## Reference\nhttps://dexie.org/docs/cloud/consistency\n\u003e \"Avoid reading + JS condition + writing. Instead formulate the condition in a where-clause with a modify expression attached to it.\"","acceptance_criteria":"- [ ] Cleanup operation is atomic (all-or-nothing)\n- [ ] No intermediate UI updates during cleanup\n- [ ] Concurrent habit additions during cleanup don't cause issues\n- [ ] Verify cloud sync doesn't interfere with cleanup operation","status":"open","priority":2,"issue_type":"bug","created_at":"2025-12-13T14:17:40.938560534Z","updated_at":"2025-12-13T14:17:40.938560534Z","labels":["data-integrity","sync"],"dependencies":[{"issue_id":"HT-0r2","depends_on_id":"HT-er4","type":"parent-child","created_at":"2025-12-13T14:17:47.391597493Z","created_by":"daemon"}]}
{"id":"HT-4xc","title":"Use update() instead of put() for single-property modifications","description":"**Severity: High**\n\nRepositories currently use `bulkPut()` which replaces entire objects. When two devices modify different properties of the same habit concurrently, last-write-wins means one change is lost.\n\n## Problem\nDevice A changes habit name, Device B changes targetPerWeek. With put(), whichever syncs last overwrites the other's change entirely.\n\n## Current Code\n```typescript\n// habitRepository.ts\nasync update(habit: Habit): Promise\u003cvoid\u003e {\n  await db.habits.put(toRecord(habit));  // Replaces entire object\n}\n```\n\n## Solution\nFor operations that modify specific fields, use `Table.update()`:\n\n```typescript\n// For targeted updates\nasync updateField(id: string, changes: Partial\u003cHabitRecord\u003e): Promise\u003cvoid\u003e {\n  await db.habits.update(id, changes);\n}\n\n// Usage\nawait habitRepository.updateField(habitId, { name: newName });\nawait habitRepository.updateField(habitId, { targetPerWeek: 5 });\n```\n\n## Scope\nIdentify all places where we modify a single property and could use update() instead:\n- Habit name changes\n- Habit category changes  \n- Habit targetPerWeek changes\n- Entry value changes (toggles)\n\n## Reference\nhttps://dexie.org/docs/cloud/best-practices\n\u003e \"Update operations manipulate individual properties rather than replacing entire objects, which prevents conflicts when two different clients mutate different properties on the same object.\"","acceptance_criteria":"- [ ] Add updateField() or similar method to repositories\n- [ ] Identify callsites that modify single properties\n- [ ] Convert appropriate callsites to use update() instead of put()\n- [ ] Keep bulkPut() for import operations (entire object replacement is intentional there)\n- [ ] Test concurrent modifications on two browser tabs","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-13T14:17:40.648215941Z","updated_at":"2025-12-13T14:17:40.648215941Z","labels":["data-integrity","sync"],"dependencies":[{"issue_id":"HT-4xc","depends_on_id":"HT-er4","type":"parent-child","created_at":"2025-12-13T14:17:47.210925523Z","created_by":"daemon"}]}
{"id":"HT-er4","title":"Dexie Cloud Synchronization Hardening","description":"Address synchronization issues identified in architecture review to prevent data loss and race conditions when using Dexie Cloud sync.\n\n## Context\nAudit against Dexie Cloud best practices revealed several patterns that could cause data loss or inconsistencies during cloud sync operations.\n\n## Key Issues\n1. Non-atomic import/replace operations\n2. Using put() instead of update() loses concurrent edits\n3. Read-condition-write patterns in cleanup operations\n\n## References\n- https://dexie.org/docs/cloud/consistency\n- https://dexie.org/docs/cloud/best-practices","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-13T14:17:09.686565221Z","updated_at":"2025-12-13T14:17:09.686565221Z","labels":["data-integrity","sync"]}
