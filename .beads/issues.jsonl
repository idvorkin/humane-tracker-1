{"id":"HT-0g4","title":"Wrap import/replace in Dexie transaction for atomicity","description":"**Severity: Critical**\n\nThe `importAllData()` function in `dataService.ts` performs 4 separate async operations without a transaction wrapper:\n\n```typescript\nif (mode === \"replace\") {\n  await habitRepository.clear();   // Op 1\n  await entryRepository.clear();   // Op 2\n}\nawait habitRepository.bulkPut(habits);   // Op 3\nawait entryRepository.bulkPut(entries);  // Op 4\n```\n\n## Problem\n- Between each step, LiveQuery subscriptions fire and UI sees inconsistent state\n- If error occurs mid-operation (e.g., after clear but before bulkPut), data is lost with no rollback\n- Cloud sync could be pushing/pulling simultaneously, causing merge conflicts\n- Violates Dexie Cloud's atomicity guarantees\n\n## Solution\nWrap in `db.transaction()`:\n\n```typescript\nimport { db } from \"../config/db\";\n\nreturn db.transaction('rw', db.habits, db.entries, async () =\u003e {\n  if (mode === \"replace\") {\n    await db.habits.clear();\n    await db.entries.clear();\n  }\n  await db.habits.bulkPut(habitsRecords);\n  await db.entries.bulkPut(entriesRecords);\n});\n```\n\n## Reference\nhttps://dexie.org/docs/cloud/consistency\n\u003e \"Any Dexie transaction will be regarded as an atomic all-or-nothing operation when it syncs to the cloud.\"","acceptance_criteria":"- [ ] importAllData wrapped in db.transaction()\n- [ ] All 4 operations (clear habits, clear entries, bulkPut habits, bulkPut entries) in same transaction\n- [ ] Error in any step rolls back entire operation\n- [ ] Existing tests still pass\n- [ ] Manual test: import with intentional error mid-way doesn't corrupt data","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-13T14:17:40.317568536Z","updated_at":"2025-12-13T14:53:27.38201373Z","closed_at":"2025-12-13T14:53:27.38201373Z","labels":["critical","data-integrity","sync"],"dependencies":[{"issue_id":"HT-0g4","depends_on_id":"HT-er4","type":"parent-child","created_at":"2025-12-13T14:17:47.069925935Z","created_by":"daemon"}]}
{"id":"HT-0r2","title":"Fix read-condition-write race in CleanupDuplicates","description":"**Severity: Medium**\n\n`CleanupDuplicates.tsx` uses a read-condition-write pattern that's vulnerable to race conditions with cloud sync.\n\n## Current Code\n```typescript\n// Read all habits\nconst habits = await habitService.getAllHabitsForUser(userId);\n// Find duplicates in JS\nconst duplicates = findDuplicates(habits);\n// Delete sequentially\nfor (const dup of duplicates) {\n  await habitService.deleteHabit(dup.id);  // Each delete triggers subscription\n}\n```\n\n## Problems\n1. If cloud sync pushes a new habit between read and delete, could delete wrong item\n2. Sequential deletes trigger subscription updates between each one\n3. User could add a habit during cleanup, causing unpredictable behavior\n\n## Solution Options\n\n**Option A: Batch delete in transaction**\n```typescript\nawait db.transaction('rw', db.habits, async () =\u003e {\n  const duplicateIds = [...]; // IDs determined before transaction\n  await db.habits.bulkDelete(duplicateIds);\n});\n```\n\n**Option B: Use where-clause (preferred for Dexie Cloud)**\n```typescript\n// Group habits by name, delete all but first in each group\n// Conditions travel to server and re-execute there\n```\n\n## Reference\nhttps://dexie.org/docs/cloud/consistency\n\u003e \"Avoid reading + JS condition + writing. Instead formulate the condition in a where-clause with a modify expression attached to it.\"","acceptance_criteria":"- [ ] Cleanup operation is atomic (all-or-nothing)\n- [ ] No intermediate UI updates during cleanup\n- [ ] Concurrent habit additions during cleanup don't cause issues\n- [ ] Verify cloud sync doesn't interfere with cleanup operation","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-13T14:17:40.938560534Z","updated_at":"2025-12-13T15:06:05.793435618Z","closed_at":"2025-12-13T15:06:05.793435618Z","labels":["data-integrity","sync"],"dependencies":[{"issue_id":"HT-0r2","depends_on_id":"HT-er4","type":"parent-child","created_at":"2025-12-13T14:17:47.391597493Z","created_by":"daemon"}]}
{"id":"HT-4xc","title":"Use update() instead of put() for single-property modifications","description":"**Severity: High**\n\nRepositories currently use `bulkPut()` which replaces entire objects. When two devices modify different properties of the same habit concurrently, last-write-wins means one change is lost.\n\n## Problem\nDevice A changes habit name, Device B changes targetPerWeek. With put(), whichever syncs last overwrites the other's change entirely.\n\n## Current Code\n```typescript\n// habitRepository.ts\nasync update(habit: Habit): Promise\u003cvoid\u003e {\n  await db.habits.put(toRecord(habit));  // Replaces entire object\n}\n```\n\n## Solution\nFor operations that modify specific fields, use `Table.update()`:\n\n```typescript\n// For targeted updates\nasync updateField(id: string, changes: Partial\u003cHabitRecord\u003e): Promise\u003cvoid\u003e {\n  await db.habits.update(id, changes);\n}\n\n// Usage\nawait habitRepository.updateField(habitId, { name: newName });\nawait habitRepository.updateField(habitId, { targetPerWeek: 5 });\n```\n\n## Scope\nIdentify all places where we modify a single property and could use update() instead:\n- Habit name changes\n- Habit category changes  \n- Habit targetPerWeek changes\n- Entry value changes (toggles)\n\n## Reference\nhttps://dexie.org/docs/cloud/best-practices\n\u003e \"Update operations manipulate individual properties rather than replacing entire objects, which prevents conflicts when two different clients mutate different properties on the same object.\"","acceptance_criteria":"- [ ] Add updateField() or similar method to repositories\n- [ ] Identify callsites that modify single properties\n- [ ] Convert appropriate callsites to use update() instead of put()\n- [ ] Keep bulkPut() for import operations (entire object replacement is intentional there)\n- [ ] Test concurrent modifications on two browser tabs","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-13T14:17:40.648215941Z","updated_at":"2025-12-13T15:02:52.631953139Z","closed_at":"2025-12-13T15:02:52.631953139Z","labels":["data-integrity","sync"],"dependencies":[{"issue_id":"HT-4xc","depends_on_id":"HT-er4","type":"parent-child","created_at":"2025-12-13T14:17:47.210925523Z","created_by":"daemon"}]}
{"id":"HT-7ii","title":"Fix buildHabitTree to derive parenthood from childIds","description":"Change the top-level detection in buildHabitTree to check if ANY tag has this habit in its childIds, not just checking parentIds. This makes the algorithm defensive against inconsistent data.\n\nIn habitTreeUtils.ts, the topLevel filter should check:\n- If habit has no parentIds AND no tag has it in childIds -\u003e top-level\n- If habit has parentIds OR any tag has it in childIds -\u003e not top-level","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-14T01:32:56.951639522Z","updated_at":"2025-12-14T01:35:20.892122278Z","closed_at":"2025-12-14T01:35:20.892122278Z"}
{"id":"HT-9z1","title":"Add test for inconsistent childIds/parentIds handling","description":"Add a unit test to habitTreeUtils.test.ts that verifies:\n1. When a child has empty parentIds but is in a tag's childIds, it should NOT appear at top-level\n2. When a tag has childIds, those children should only appear under the tag (when expanded)\n\nThis prevents regression of the duplicate display bug.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-14T01:33:09.37167536Z","updated_at":"2025-12-14T01:35:20.893645372Z","closed_at":"2025-12-14T01:35:20.893645372Z"}
{"id":"HT-dtv","title":"Add parentIds/childIds sync validation on data load and import","description":"Add a repair function that ensures parentIds and childIds are in sync:\n1. For each tag with childIds, ensure each child has this tag in its parentIds\n2. For each habit with parentIds, ensure each parent tag has this habit in its childIds\n\nRun this function:\n- When loading habits in habitService.getHabitsWithStatus\n- During data import in importAllData\n\nThis catches historical inconsistencies and import issues.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-14T01:33:03.792540999Z","updated_at":"2025-12-14T01:33:03.792540999Z"}
{"id":"HT-er4","title":"Dexie Cloud Synchronization Hardening","description":"Address synchronization issues identified in architecture review to prevent data loss and race conditions when using Dexie Cloud sync.\n\n## Context\nAudit against Dexie Cloud best practices revealed several patterns that could cause data loss or inconsistencies during cloud sync operations.\n\n## Key Issues\n1. Non-atomic import/replace operations\n2. Using put() instead of update() loses concurrent edits\n3. Read-condition-write patterns in cleanup operations\n\n## References\n- https://dexie.org/docs/cloud/consistency\n- https://dexie.org/docs/cloud/best-practices","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-13T14:17:09.686565221Z","updated_at":"2025-12-13T15:06:12.117426725Z","closed_at":"2025-12-13T15:06:12.117426725Z","labels":["data-integrity","sync"]}
{"id":"HT-sb8","title":"Bug: Tag children appear at top-level AND under tag (duplicate display)","description":"When childIds and parentIds are out of sync, child habits appear twice: once at category top-level (because empty parentIds) and once under the tag (because tag has childIds pointing to them). This happens because:\n1. buildHabitTree uses parentIds to determine top-level\n2. But tree structure is built using childIds\n3. If a child has empty parentIds but is in a tag's childIds, it shows in both places","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-14T01:32:49.647496155Z","updated_at":"2025-12-14T01:35:45.434139402Z","closed_at":"2025-12-14T01:35:45.434139402Z","dependencies":[{"issue_id":"HT-sb8","depends_on_id":"HT-7ii","type":"blocks","created_at":"2025-12-14T01:33:13.558669718Z","created_by":"daemon"},{"issue_id":"HT-sb8","depends_on_id":"HT-9z1","type":"blocks","created_at":"2025-12-14T01:33:13.564824323Z","created_by":"daemon"}]}
